<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>StarFinder AR</title>
    <style>
        :root {
            --hud-color: #00ffff;
            --hud-bg: rgba(0, 20, 30, 0.85);
            --alert-color: #ff3333;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: var(--hud-color);
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* HUD LAYOUT */
        #hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .hud-status {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--hud-color);
        }

        .hud-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* CROSSHAIR */
        .reticle {
            width: 60px;
            height: 60px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
        }
        .reticle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: var(--hud-color);
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }
        .reticle-corner {
            position: absolute;
            width: 10px;
            height: 10px;
            border-color: var(--hud-color);
            border-style: solid;
        }
        .tl { top: -5px; left: -5px; border-width: 2px 0 0 2px; }
        .tr { top: -5px; right: -5px; border-width: 2px 2px 0 0; }
        .bl { bottom: -5px; left: -5px; border-width: 0 0 2px 2px; }
        .br { bottom: -5px; right: -5px; border-width: 0 2px 2px 0; }

        /* INFO PANEL */
        #info-panel {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 400px;
            background: var(--hud-bg);
            border: 1px solid var(--hud-color);
            padding: 15px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
        }
        #info-panel.active {
            opacity: 1;
        }
        #target-name {
            font-size: 1.5em;
            font-weight: bold;
            margin: 0 0 5px 0;
            text-transform: uppercase;
        }
        #target-desc {
            font-size: 0.9em;
            opacity: 0.8;
            margin: 0;
        }

        /* START OVERLAY */
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        h1 {
            font-size: 2.5em;
            letter-spacing: 5px;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 0 10px var(--hud-color);
        }

        .btn {
            background: transparent;
            color: var(--hud-color);
            border: 2px solid var(--hud-color);
            padding: 15px 40px;
            font-family: inherit;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover {
            background: var(--hud-color);
            color: black;
            box-shadow: 0 0 20px var(--hud-color);
        }

        .loading {
            margin-top: 20px;
            font-size: 0.8em;
            color: #888;
        }

    </style>
    
    <!-- Import Map for Three.js and Controls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <!-- HUD -->
    <div id="hud-layer">
        <div class="hud-top">
            <div id="gps-status" class="hud-status">GPS: SEARCHING...</div>
            <div id="lst-time" class="hud-status">LST: 00:00</div>
        </div>
        
        <div class="hud-center">
            <div class="reticle">
                <div class="reticle-corner tl"></div>
                <div class="reticle-corner tr"></div>
                <div class="reticle-corner bl"></div>
                <div class="reticle-corner br"></div>
            </div>
        </div>

        <div id="info-panel">
            <h2 id="target-name">Target</h2>
            <p id="target-desc">Description</p>
        </div>
    </div>

    <!-- Start Overlay -->
    <div id="start-overlay">
        <h1>STARFINDER</h1>
        <p style="text-align:center; max-width: 80%;">
            Augmented Reality Sky Scanner.<br>
            Please allow GPS and Device Orientation.
        </p>
        <button id="start-btn" class="btn">INITIALIZE SYSTEMS</button>
        <div id="permission-log" class="loading">Waiting for user input...</div>
    </div>

    <!-- Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DeviceOrientationControls } from 'three/addons/controls/DeviceOrientationControls.js';

        // --- CONFIGURATION ---
        const STAR_COUNT = 800; // Background stars
        const SPHERE_RADIUS = 500;
        const CONSTELLATION_COLOR = 0x00ffff;
        
        // --- DATA: CONSTELLATIONS ---
        // RA in Hours (0-24), Dec in Degrees (-90 to 90)
        // Structure: Name, Description, Lines (pairs of star indices), Stars (coords)
        const DATABASE = [
            {
                id: 'orion',
                name: 'Orion',
                desc: 'The Hunter. Prominent constellation located on the celestial equator.',
                stars: [
                    { ra: 5.91, dec: 7.4, name: 'Betelgeuse' }, // 0
                    { ra: 5.24, dec: 6.3, name: 'Bellatrix' },  // 1
                    { ra: 5.55, dec: -0.3, name: 'Mintaka' },   // 2 (Belt)
                    { ra: 5.60, dec: -1.2, name: 'Alnilam' },   // 3 (Belt)
                    { ra: 5.67, dec: -1.9, name: 'Alnitak' },   // 4 (Belt)
                    { ra: 5.79, dec: -9.6, name: 'Saiph' },     // 5
                    { ra: 5.24, dec: -8.2, name: 'Rigel' }      // 6
                ],
                connections: [[0,1], [1,2], [2,3], [3,4], [4,5], [4,0], [2,6]]
            },
            {
                id: 'ursa_major',
                name: 'Ursa Major',
                desc: 'The Great Bear. Contains the Big Dipper asterism.',
                stars: [
                    { ra: 11.06, dec: 61.75, name: 'Dubhe' },   // 0
                    { ra: 11.03, dec: 56.38, name: 'Merak' },   // 1
                    { ra: 11.89, dec: 53.69, name: 'Phecda' },  // 2
                    { ra: 12.25, dec: 57.03, name: 'Megrez' },  // 3
                    { ra: 12.90, dec: 55.95, name: 'Alioth' },  // 4
                    { ra: 13.39, dec: 54.92, name: 'Mizar' },   // 5
                    { ra: 13.79, dec: 49.31, name: 'Alkaid' }   // 6
                ],
                connections: [[0,1], [1,2], [2,3], [3,0], [3,4], [4,5], [5,6]]
            },
            {
                id: 'bootes',
                name: 'Bootes',
                desc: 'The Herdsman. Contains Arcturus, the third-brightest star.',
                stars: [
                    { ra: 14.26, dec: 19.18, name: 'Arcturus' }, // 0
                    { ra: 14.77, dec: 27.07, name: 'Izar' },     // 1
                    { ra: 13.91, dec: 18.39, name: 'Muphrid' },  // 2
                    { ra: 15.26, dec: 33.31, name: 'Seginus' },  // 3
                    { ra: 14.53, dec: 38.30, name: 'Nekkar' },   // 4
                    { ra: 14.73, dec: 40.39, name: 'Alkalurops'} // 5
                ],
                connections: [[0,1], [0,2], [1,3], [3,4], [4,5]]
            }
        ];

        // --- APP STATE ---
        let scene, camera, renderer, controls;
        let starContainer; // Holds all stars to rotate them together
        let raycaster;
        let constellationHitSpheres = []; // Invisible spheres for collision detection
        
        let userLat = 0;
        let userLon = 0;
        let gpsLocked = false;
        let deviceControlActive = false;

        // --- INITIALIZATION ---
        function init() {
            // Scene Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // Background color is handled by CSS, but fog helps depth
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Initial look direction (North)
            camera.position.set(0, 0, 0.1); 

            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Objects Group
            starContainer = new THREE.Group();
            scene.add(starContainer);

            // Tools
            raycaster = new THREE.Raycaster();

            // Populate Sky
            createProceduralStars();
            createConstellations();

            // Events
            window.addEventListener('resize', onWindowResize);
        }

        // --- ASTRONOMY MATH ---

        // Convert RA (hours), Dec (degrees) to Cartesian (x,y,z) on unit sphere
        function raDecToVector(ra, dec, radius) {
            // RA: 0h = 0deg, 24h = 360deg. 
            // In ThreeJS (Y-up), we map Celestial Sphere:
            // Y axis = Celestial North Pole (Dec = 90)
            // X/Z plane = Celestial Equator (Dec = 0)
            
            const phi = (90 - dec) * (Math.PI / 180); // Polar angle (from up axis)
            const theta = (ra / 24) * 2 * Math.PI; // Azimuthal angle (RA) - standard math usually uses right-hand rule
            
            // Note: We negate theta or swap sin/cos depending on coordinate system chirality. 
            // Here we use standard spherical conversion.
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi); // Y is UP (North)
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }

        // Generate a soft glow texture programmatically
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- OBJECT CREATION ---

        function createProceduralStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            for (let i = 0; i < STAR_COUNT; i++) {
                // Random spherical distribution
                const r = SPHERE_RADIUS;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({ 
                color: 0x888888, 
                size: 2, 
                sizeAttenuation: false 
            });

            const points = new THREE.Points(geometry, material);
            starContainer.add(points);
        }

        function createConstellations() {
            const starTexture = createStarTexture();
            const material = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 15, 
                map: starTexture, 
                transparent: true,
                depthWrite: false
            });

            const lineMaterial = new THREE.LineBasicMaterial({
                color: CONSTELLATION_COLOR,
                transparent: true,
                opacity: 0.4,
                linewidth: 2
            });

            DATABASE.forEach(constellation => {
                const starPositions = [];
                const geometry = new THREE.BufferGeometry();
                const vertices = []; // For lines

                // 1. Create Stars
                constellation.stars.forEach(star => {
                    const pos = raDecToVector(star.ra, star.dec, SPHERE_RADIUS);
                    starPositions.push(pos.x, pos.y, pos.z);
                });
                
                const starGeo = new THREE.BufferGeometry();
                starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
                const starPoints = new THREE.Points(starGeo, material);
                starContainer.add(starPoints);

                // 2. Create Lines
                constellation.connections.forEach(pair => {
                    const idx1 = pair[0];
                    const idx2 = pair[1];
                    const v1 = new THREE.Vector3(starPositions[idx1*3], starPositions[idx1*3+1], starPositions[idx1*3+2]);
                    const v2 = new THREE.Vector3(starPositions[idx2*3], starPositions[idx2*3+1], starPositions[idx2*3+2]);
                    vertices.push(v1.x, v1.y, v1.z);
                    vertices.push(v2.x, v2.y, v2.z);
                });

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const lines = new THREE.LineSegments(geometry, lineMaterial);
                starContainer.add(lines);

                // 3. Create Interaction Hit Sphere (Invisible center point)
                // Calculate average position (center of constellation)
                let cx=0, cy=0, cz=0;
                let count = constellation.stars.length;
                for(let i=0; i<starPositions.length; i+=3) {
                    cx += starPositions[i];
                    cy += starPositions[i+1];
                    cz += starPositions[i+2];
                }
                const center = new THREE.Vector3(cx/count, cy/count, cz/count);
                
                // Add invisible sphere for raycasting
                const hitGeo = new THREE.SphereGeometry(40, 8, 8);
                const hitMat = new THREE.MeshBasicMaterial({ visible: false, wireframe: true });
                const hitMesh = new THREE.Mesh(hitGeo, hitMat);
                hitMesh.position.copy(center);
                hitMesh.userData = { id: constellation.id, name: constellation.name, desc: constellation.desc };
                
                starContainer.add(hitMesh);
                constellationHitSpheres.push(hitMesh);
            });
        }

        // --- ALIGNMENT LOGIC ---

        function getGreenwichSiderealTime() {
            const now = new Date();
            // Julian Date
            const julian = (now.getTime() / 86400000) + 2440587.5;
            const D = julian - 2451545.0; // Days since J2000
            
            // GMST formula
            let gmst = 18.697374558 + 24.06570982441908 * D;
            gmst = gmst % 24;
            if (gmst < 0) gmst += 24;
            return gmst;
        }

        function updateSkyAlignment() {
            if (!gpsLocked) return;

            const gmst = getGreenwichSiderealTime();
            // LST = GMST + Longitude (in hours)
            // Longitude is degrees, convert to hours (deg / 15)
            const lonHours = userLon / 15;
            let lst = gmst + lonHours;
            if (lst < 0) lst += 24;
            if (lst > 24) lst -= 24;

            // Update HUD
            const h = Math.floor(lst);
            const m = Math.floor((lst - h) * 60);
            document.getElementById('lst-time').innerText = `LST: ${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;

            // ROTATE THE SKY CONTAINER
            // 1. Reset rotation
            starContainer.rotation.set(0, 0, 0);

            // 2. Adjust for Latitude (Tilt the Pole)
            // At Lat 90 (North Pole), Celestial Pole is at Zenith (Y).
            // At Lat 0 (Equator), Celestial Pole is at Horizon (Z).
            // ThreeJS Y is UP. 
            // We need to rotate around X axis.
            // If Lat = 90, no rotation. If Lat = 0, rotate -90 deg (-PI/2).
            const latRad = userLat * (Math.PI / 180);
            const latCorrection = (Math.PI / 2) - latRad;
            starContainer.rotateX(latCorrection);

            // 3. Adjust for LST (Earth's Rotation)
            // This rotates the sky around the Celestial Pole (now tilted).
            // LST corresponds to the RA currently at the Meridian.
            // Rotate around local Y (after tilt) or global Y? 
            // The stars are defined by RA/Dec. 
            // We need to rotate the sphere around its own "North" axis.
            // Since we applied X rotation to the container, the container's Y axis is now the Pole.
            // We rotate around that axis.
            // Rotation amount = LST converted to radians.
            // Stars move East to West. Earth spins West to East.
            // We need to rotate the sky: -LST * 15deg
            const lstRad = lst * (Math.PI / 12); // (lst / 24) * 2PI
            starContainer.rotateY(-lstRad);
            
            // Note: Detailed alignment involves transforming coordinate spaces more rigorously,
            // but for a fun AR visualizer, tilting for Lat and spinning for LST is the core logic.
        }

        // --- INTERACTION & LOOP ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function checkInteractions() {
            // Raycast from center of screen
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Check against constellation hit spheres
            const intersects = raycaster.intersectObjects(constellationHitSpheres);

            const panel = document.getElementById('info-panel');
            
            if (intersects.length > 0) {
                const data = intersects[0].object.userData;
                document.getElementById('target-name').innerText = data.name;
                document.getElementById('target-desc').innerText = data.desc;
                panel.classList.add('active');
            } else {
                panel.classList.remove('active');
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls) controls.update();
            
            // Keep alignment updated (time passes)
            if(gpsLocked) updateSkyAlignment();

            checkInteractions();
            renderer.render(scene, camera);
        }

        // --- PERMISSIONS & STARTUP ---

        const btn = document.getElementById('start-btn');
        const overlay = document.getElementById('start-overlay');
        const log = document.getElementById('permission-log');
        const gpsStatus = document.getElementById('gps-status');

        btn.addEventListener('click', async () => {
            log.innerText = "Requesting System Access...";
            
            // 1. Initialize Three.js
            init();

            // 2. Request DeviceOrientation (iOS 13+ requirement)
            try {
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        log.innerText = "Sensors: OK. Waiting for GPS...";
                        setupMobileControls();
                    } else {
                        log.innerText = "Sensors: Denied. Using touch controls.";
                        setupDesktopControls();
                    }
                } else {
                    // Non-iOS 13+ devices or Desktop
                    log.innerText = "Sensors: Auto/Desktop.";
                    if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                         setupMobileControls();
                    } else {
                         setupDesktopControls();
                    }
                }
            } catch (e) {
                console.error(e);
                log.innerText = "Sensor Error. Using manual controls.";
                setupDesktopControls();
            }

            // 3. Request GPS
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userLat = position.coords.latitude;
                        userLon = position.coords.longitude;
                        gpsLocked = true;
                        gpsStatus.innerText = `GPS: LOCKED [${userLat.toFixed(2)}, ${userLon.toFixed(2)}]`;
                        gpsStatus.style.color = '#00ff00';
                        
                        // Initial alignment immediately
                        updateSkyAlignment();
                        
                        // Hide overlay
                        overlay.style.display = 'none';
                        animate();
                    },
                    (error) => {
                        console.warn("GPS Denied", error);
                        gpsStatus.innerText = "GPS: OFF (DEFAULTING)";
                        gpsStatus.style.color = 'orange';
                        // Default to Londonish
                        userLat = 51.5;
                        userLon = 0;
                        gpsLocked = true; // Pretend we are locked to enable rotation logic
                        
                        overlay.style.display = 'none';
                        animate();
                    }
                );
            } else {
                log.innerText = "GPS Not supported.";
                setTimeout(() => { overlay.style.display = 'none'; animate(); }, 1000);
            }
        });

        function setupMobileControls() {
            deviceControlActive = true;
            controls = new DeviceOrientationControls(camera);
            controls.alphaOffset = 0; // Compass alignment adjustment if needed
        }

        function setupDesktopControls() {
            deviceControlActive = false;
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false;
            controls.enablePan = false;
            controls.rotateSpeed = -0.5; // Invert for "looking around" feel
        }

    </script>
</body>
</html>
